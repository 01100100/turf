{"version":3,"file":"index.js","sources":["../index.js"],"sourcesContent":["/**\n * GeoJSON BBox\n *\n * @private\n * @typedef {[number, number, number, number]} BBox\n */\n\n/**\n * GeoJSON Id\n *\n * @private\n * @typedef {(number|string)} Id\n */\n\n/**\n * GeoJSON FeatureCollection\n *\n * @private\n * @typedef {Object} FeatureCollection\n * @property {string} type\n * @property {?Id} id\n * @property {?BBox} bbox\n * @property {Feature[]} features\n */\n\n/**\n * GeoJSON Feature\n *\n * @private\n * @typedef {Object} Feature\n * @property {string} type\n * @property {?Id} id\n * @property {?BBox} bbox\n * @property {*} properties\n * @property {Geometry} geometry\n */\n\n/**\n * GeoJSON Geometry\n *\n * @private\n * @typedef {Object} Geometry\n * @property {string} type\n * @property {any[]} coordinates\n */\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        var featureSubIndex = 0;\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    featureSubIndex++;\n                }\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                        featureSubIndex++;\n                    }\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                            featureSubIndex++;\n                        }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                featureIndex++;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                featureIndex++;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                    featureIndex++;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases for each iterating line segment.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex) {\n        var featureSubIndex = 0;\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex);\n            featureSubIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} [currentIndex] The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} [currentSubIndex] The subindex of the current element being processed in the\n * array. Starts at index 0 and increases for each iterating line segment.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, currentIndex, currentSubIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= currentIndex\n *   //= currentSubIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    segmentEach(geojson, function (currentSegment, currentIndex, currentSubIndex) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, currentIndex, currentSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nexport function feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nexport function lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6EA,AAAO,SAAS,SAAS,CAAC,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;;IAE3D,IAAI,OAAO,KAAK,IAAI,EAAE,OAAO;IAC7B,IAAI,YAAY,EAAE,aAAa,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM;QAC7D,uBAAuB;QACvB,UAAU,GAAG,CAAC;QACd,UAAU,GAAG,CAAC;QACd,oBAAoB;QACpB,IAAI,GAAG,OAAO,CAAC,IAAI;QACnB,mBAAmB,GAAG,IAAI,KAAK,mBAAmB;QAClD,SAAS,GAAG,IAAI,KAAK,SAAS;QAC9B,IAAI,GAAG,mBAAmB,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;;;;;;;;;;;;;;IAc7D,KAAK,YAAY,GAAG,CAAC,EAAE,YAAY,GAAG,IAAI,EAAE,YAAY,EAAE,EAAE;QACxD,IAAI,eAAe,GAAG,CAAC,CAAC;;QAExB,uBAAuB,IAAI,mBAAmB,GAAG,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,QAAQ;aACnF,SAAS,GAAG,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC;QAC9C,oBAAoB,GAAG,CAAC,uBAAuB,IAAI,uBAAuB,CAAC,IAAI,KAAK,oBAAoB,GAAG,KAAK,CAAC;QACjH,KAAK,GAAG,oBAAoB,GAAG,uBAAuB,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;;QAE7E,KAAK,aAAa,GAAG,CAAC,EAAE,aAAa,GAAG,KAAK,EAAE,aAAa,EAAE,EAAE;YAC5D,QAAQ,GAAG,oBAAoB;gBAC3B,uBAAuB,CAAC,UAAU,CAAC,aAAa,CAAC,GAAG,uBAAuB,CAAC;;;YAGhF,IAAI,QAAQ,KAAK,IAAI,EAAE,SAAS;YAChC,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC;YAC9B,IAAI,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC;;YAE7B,UAAU,GAAG,CAAC,gBAAgB,KAAK,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;;YAEnG,QAAQ,QAAQ;YAChB,KAAK,IAAI;gBACL,MAAM;YACV,KAAK,OAAO;gBACR,QAAQ,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;gBAC5D,UAAU,EAAE,CAAC;gBACb,eAAe,EAAE,CAAC;gBAClB,MAAM;YACV,KAAK,YAAY,CAAC;YAClB,KAAK,YAAY;gBACb,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAChC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;oBAC/D,UAAU,EAAE,CAAC;oBACb,eAAe,EAAE,CAAC;iBACrB;gBACD,MAAM;YACV,KAAK,SAAS,CAAC;YACf,KAAK,iBAAiB;gBAClB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE;oBAC9B,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;wBAChD,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;wBAClE,UAAU,EAAE,CAAC;wBACb,eAAe,EAAE,CAAC;qBACrB;gBACL,MAAM;YACV,KAAK,cAAc;gBACf,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE;oBAC9B,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE;wBACjC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;4BACnD,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;4BACrE,UAAU,EAAE,CAAC;4BACb,eAAe,EAAE,CAAC;yBACrB;gBACT,MAAM;YACV,KAAK,oBAAoB;gBACrB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE;oBAC3C,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,gBAAgB,CAAC,CAAC;gBAClE,MAAM;YACV;gBACI,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;aAC5C;SACJ;KACJ;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDD,AAAO,SAAS,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,gBAAgB,EAAE;IAC3E,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,SAAS,CAAC,OAAO,EAAE,UAAU,YAAY,EAAE,UAAU,EAAE,YAAY,EAAE,eAAe,EAAE;QAClF,IAAI,UAAU,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,YAAY,CAAC;aAC5E,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,YAAY,EAAE,UAAU,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;KACzG,EAAE,gBAAgB,CAAC,CAAC;IACrB,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BD,AAAO,SAAS,QAAQ,CAAC,OAAO,EAAE,QAAQ,EAAE;IACxC,IAAI,CAAC,CAAC;IACN,QAAQ,OAAO,CAAC,IAAI;IACpB,KAAK,mBAAmB;QACpB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;SAC/C;QACD,MAAM;IACV,KAAK,SAAS;QACV,QAAQ,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;QAChC,MAAM;KACT;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDD,AAAO,SAAS,UAAU,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;IACxD,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,QAAQ,CAAC,OAAO,EAAE,UAAU,iBAAiB,EAAE,YAAY,EAAE;QACzD,IAAI,YAAY,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,iBAAiB,CAAC;aACnF,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,iBAAiB,EAAE,YAAY,CAAC,CAAC;KACjF,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BD,AAAO,SAAS,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE;IAC3C,IAAI,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE;QAC5B,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;KACxB,MAAM,IAAI,OAAO,CAAC,IAAI,KAAK,mBAAmB,EAAE;QAC7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC9C,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SACpC;KACJ;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CD,AAAO,SAAS,aAAa,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;IAC3D,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,WAAW,CAAC,OAAO,EAAE,UAAU,cAAc,EAAE,YAAY,EAAE;QACzD,IAAI,YAAY,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,cAAc,CAAC;aAChF,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;KAC9E,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;;;;;;;;AAiBD,AAAO,SAAS,QAAQ,CAAC,OAAO,EAAE;IAC9B,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,SAAS,CAAC,OAAO,EAAE,UAAU,KAAK,EAAE;QAChC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACtB,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;CACjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BD,AAAO,SAAS,QAAQ,CAAC,OAAO,EAAE,QAAQ,EAAE;IACxC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,KAAK;QACxB,uBAAuB;QACvB,oBAAoB;QACpB,kBAAkB;QAClB,YAAY,GAAG,CAAC;QAChB,mBAAmB,GAAG,OAAO,CAAC,IAAI,KAAK,mBAAmB;QAC1D,SAAS,GAAG,OAAO,CAAC,IAAI,KAAK,SAAS;QACtC,IAAI,GAAG,mBAAmB,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;;;;;;;;;;;;;;IAc7D,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;;QAEvB,uBAAuB,IAAI,mBAAmB,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ;aACxE,SAAS,GAAG,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC;QAC9C,kBAAkB,IAAI,mBAAmB,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,UAAU;aACrE,SAAS,GAAG,OAAO,CAAC,UAAU,GAAG,EAAE,CAAC,CAAC,CAAC;QAC3C,oBAAoB,GAAG,CAAC,uBAAuB,IAAI,uBAAuB,CAAC,IAAI,KAAK,oBAAoB,GAAG,KAAK,CAAC;QACjH,KAAK,GAAG,oBAAoB,GAAG,uBAAuB,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;;QAE7E,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;YACxB,QAAQ,GAAG,oBAAoB;gBAC3B,uBAAuB,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,uBAAuB,CAAC;;;YAGpE,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACnB,QAAQ,CAAC,IAAI,EAAE,YAAY,EAAE,kBAAkB,CAAC,CAAC;gBACjD,YAAY,EAAE,CAAC;gBACf,SAAS;aACZ;YACD,QAAQ,QAAQ,CAAC,IAAI;YACrB,KAAK,OAAO,CAAC;YACb,KAAK,YAAY,CAAC;YAClB,KAAK,YAAY,CAAC;YAClB,KAAK,SAAS,CAAC;YACf,KAAK,iBAAiB,CAAC;YACvB,KAAK,cAAc,EAAE;gBACjB,QAAQ,CAAC,QAAQ,EAAE,YAAY,EAAE,kBAAkB,CAAC,CAAC;gBACrD,YAAY,EAAE,CAAC;gBACf,MAAM;aACT;YACD,KAAK,oBAAoB,EAAE;gBACvB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC7C,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,kBAAkB,CAAC,CAAC;oBACnE,YAAY,EAAE,CAAC;iBAClB;gBACD,MAAM;aACT;YACD;gBACI,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;aAC5C;SACJ;KACJ;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CD,AAAO,SAAS,UAAU,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;IACxD,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,QAAQ,CAAC,OAAO,EAAE,UAAU,eAAe,EAAE,YAAY,EAAE,iBAAiB,EAAE;QAC1E,IAAI,YAAY,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,eAAe,CAAC;aACjF,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,eAAe,EAAE,YAAY,EAAE,iBAAiB,CAAC,CAAC;KAClG,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCD,AAAO,SAAS,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE;IAC3C,QAAQ,CAAC,OAAO,EAAE,UAAU,QAAQ,EAAE,YAAY,EAAE,UAAU,EAAE;;QAE5D,IAAI,IAAI,GAAG,CAAC,QAAQ,KAAK,IAAI,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;QACtD,QAAQ,IAAI;QACZ,KAAK,IAAI,CAAC;QACV,KAAK,OAAO,CAAC;QACb,KAAK,YAAY,CAAC;QAClB,KAAK,SAAS;YACV,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,UAAU,CAAC,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC;YACzD,OAAO;SACV;;QAED,IAAI,QAAQ,CAAC;;;QAGb,QAAQ,IAAI;QACZ,KAAK,YAAY;YACb,QAAQ,GAAG,OAAO,CAAC;YACnB,MAAM;QACV,KAAK,iBAAiB;YAClB,QAAQ,GAAG,YAAY,CAAC;YACxB,MAAM;QACV,KAAK,cAAc;YACf,QAAQ,GAAG,SAAS,CAAC;YACrB,MAAM;SACT;;QAED,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,UAAU,EAAE,eAAe,EAAE;YAChE,IAAI,IAAI,GAAG;gBACP,IAAI,EAAE,QAAQ;gBACd,WAAW,EAAE,UAAU;aAC1B,CAAC;YACF,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;SACtE,CAAC,CAAC;;KAEN,CAAC,CAAC;CACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDD,AAAO,SAAS,aAAa,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;IAC3D,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,WAAW,CAAC,OAAO,EAAE,UAAU,cAAc,EAAE,YAAY,EAAE,eAAe,EAAE;QAC1E,IAAI,YAAY,KAAK,CAAC,IAAI,eAAe,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,cAAc,CAAC;aACzG,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,cAAc,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;KAC/F,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCD,AAAO,SAAS,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE;IAC3C,WAAW,CAAC,OAAO,EAAE,UAAU,OAAO,EAAE,YAAY,EAAE;QAClD,IAAI,eAAe,GAAG,CAAC,CAAC;;QAExB,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO;;QAE9B,IAAI,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;QACjC,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,YAAY,EAAE,OAAO;;;QAGtD,WAAW,CAAC,OAAO,EAAE,UAAU,cAAc,EAAE,YAAY,EAAE;YACzD,IAAI,cAAc,GAAG,UAAU,CAAC,CAAC,cAAc,EAAE,YAAY,CAAC,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;YACpF,QAAQ,CAAC,cAAc,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;YACxD,eAAe,EAAE,CAAC;YAClB,OAAO,YAAY,CAAC;SACvB,CAAC,CAAC;KACN,CAAC,CAAC;CACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDD,AAAO,SAAS,aAAa,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;IAC3D,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,WAAW,CAAC,OAAO,EAAE,UAAU,cAAc,EAAE,YAAY,EAAE,eAAe,EAAE;QAC1E,IAAI,YAAY,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,cAAc,CAAC;aAChF,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,cAAc,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;KAC/F,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;AAUD,AAAO,SAAS,OAAO,CAAC,QAAQ,EAAE,UAAU,EAAE;IAC1C,IAAI,QAAQ,KAAK,SAAS,EAAE,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;;IAElE,OAAO;QACH,IAAI,EAAE,SAAS;QACf,UAAU,EAAE,UAAU,IAAI,EAAE;QAC5B,QAAQ,EAAE,QAAQ;KACrB,CAAC;CACL;;;;;;;;;;AAUD,AAAO,SAAS,UAAU,CAAC,WAAW,EAAE,UAAU,EAAE;IAChD,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;IAC3D,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAC;;IAErG,OAAO;QACH,IAAI,EAAE,SAAS;QACf,UAAU,EAAE,UAAU,IAAI,EAAE;QAC5B,QAAQ,EAAE;YACN,IAAI,EAAE,YAAY;YAClB,WAAW,EAAE,WAAW;SAC3B;KACJ,CAAC;CACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BD,AAAO,SAAS,QAAQ,CAAC,OAAO,EAAE,QAAQ,EAAE;;IAExC,IAAI,CAAC,OAAO,EAAE,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACrD,IAAI,IAAI,GAAG,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IACnE,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IAC9C,IAAI,IAAI,KAAK,mBAAmB,EAAE,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;IACxF,IAAI,IAAI,KAAK,oBAAoB,EAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;IAC1F,IAAI,WAAW,GAAG,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;IACxF,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;;IAEtE,QAAQ,IAAI;IACZ,KAAK,YAAY;QACb,QAAQ,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5B,OAAO;IACX,KAAK,SAAS,CAAC;IACf,KAAK,iBAAiB;QAClB,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;YAClD,IAAI,IAAI,KAAK,iBAAiB,EAAE,QAAQ,GAAG,IAAI,CAAC;YAChD,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;SAC/C;QACD,OAAO;IACX,KAAK,cAAc;QACf,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACrD,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;gBACzD,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;aACnD;SACJ;QACD,OAAO;IACX;QACI,MAAM,IAAI,KAAK,CAAC,IAAI,GAAG,yBAAyB,CAAC,CAAC;KACrD;CACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CD,AAAO,SAAS,UAAU,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;IACxD,IAAI,aAAa,GAAG,YAAY,CAAC;IACjC,QAAQ,CAAC,OAAO,EAAE,UAAU,WAAW,EAAE,SAAS,EAAE,YAAY,EAAE;QAC9D,IAAI,SAAS,KAAK,CAAC,IAAI,YAAY,KAAK,SAAS,EAAE,aAAa,GAAG,WAAW,CAAC;aAC1E,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,WAAW,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;KACtF,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;CACxB;;;;;;;;;;;;;;;;;;;;"}